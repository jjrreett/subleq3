.macro jmp! a;
    z z a;
.endm

.macro clr! a;
    a;
.endm

######## b = b + a ########
.macro add! a b;
    a z; z b; z;
.endm

######## b = a ########
.macro cpy! a b;
    b; a z; z b; z;
.endm


######## a = a - 1 ########
.macro dec! a;
    p1 a;
.endm

######## a = a + 1 ########
.macro inc! a;
    m1 a;
.endm


######## if a <= 0: jmp b ########
.macro jleqz! a b;
    z a b;
.endm

######## if a >= 0: jmp b ########
.macro jgeqz! a b;
    a z jump; z z return;                           # 0 -> 0, jump; + -> -, jump; - -> +, return
    jump:
        z z b;
    return:
.endm

######## if a <  0: jmp b ########
.macro jltz! a b;
    inc! a; jleqz! a jump; dec! a; z z return;      # 0 -> +, return; + -> +, return; - -> -|+, jump # TODO OVERFLOW case (+ -> -)
    jump:
        dec! a; z z b;
    return:
.endm

######## if a >  0: jmp b ########
.macro jgtz! a b;
    dec! a; jgeqz! a jump; inc! a; z z return;      # 0 -> -, jump; + -> +|0, jump; - -> -, return # TODO OVERFLOW case (- -> +)
    jump:
        inc! a; z z b;
    return:
.endm



######## b = b * a ########
.macro mul! a b;
        inc! a;
    loop:
        p1 a break; # decrement 'a' by 1, break if 0
        add! b tmp;
        z z loop;
    break:
        b; add! tmp b; tmp tmp return;

    .data tmp: 0 .endd
    return:
.endm

######## a = a + a ########
.macro double! a;
    add! a a;
.endm

######## b = b << a ########
.macro lshift! a b;
    cpy! a counter;
    inc! counter;
    loop:
        p1 counter return;                                        # decrement counter by 1, return if 0
        double! b; jmp! loop;
    .data counter: 0 .endd
    return:
.endm


######## b = b >> a ########
.macro rshift! a b;
        
        add! literal_16 count;
        b count; 
        inc! count;

        p1 count end; # if count is <= 1: end

        z z rshift_start;

    shift:
        double! a; double! out;

    rshift_start:
        tmp tmp; add! a tmp; m1 tmp inc_out;         # if the first bit of a is 1, inc out else shift
        tmp tmp check_break;

    inc_out:
        m1 out;

    check_break:
        p1 count end; # if count is <= 1: end
        z z shift;

    end:
        b b; add! out b; z z return;

    .data 
        count: 0
        tmp: 0
        out: 0
    .endd

    return:
.endm

####### b = b * a #########
.macro fastmul! a b; # WIP
    while:
        jleqz! b return;                                           # if b <= 0: return
        cpy! b tmp; lshift! literal_15 tmp; jgeqz! tmp shift;      # if b & 1:
        add! a result; result IO;                                  #     result += a
    shift:
        double! a;                                                 # double a
        rshift! p1 b;                                              # halve b
        jmp! while;
    .data result: 0 tmp: 0 .endd
    return:
        cpy! result b;
.endm





# dest is the place where we want the value
# ptr is the addrs of the -value (as long as we negate the number going in, we can negate it going out)
# executes the date block, falls through
.macro read_deref! ptr dest;
    # b <- a
    
    clr! code_a;
    clr! code_a0;
    clr! code_a1;
    ptr z;
    z code_a;
    z code_a0;
    z code_a1; 
    clr! z;
    cpy! ptr code_a;
    dest dest code_a;             # clear dest and jump code_a

    .data
        # Two self modifying instructions
        code_a: 0                # dest -= *code_a
                dest
                ?
       code_a0: 0                # clr! *code_a
       code_a1: 0
                ?
    .endd
.endm

.macro write_deref! src ptr;
    # b <- a

    cpy! ptr code_b;
    jmp! code_a;

    .data
        code_a:  src              # This will become: subleq val, dest, ...
        code_b:  0
        code_c:  ?                # next instruction
    .endd
.endm


jmp! test;
.data 0 .endd                    # ALIGNMENT addr 3 is the IO addr

# simple_pointer_dref_example:
#     IO a;
# 
#     write_deref! a ptr;
#     read_deref! ptr dest;
# 
#     dest IO;
#     z z HALT; 

# stack_shenanigans:
# 
#     IO a; write_deref! a stack_ptr; inc! stack_ptr; clr! a;
#     IO a; write_deref! a stack_ptr; inc! stack_ptr; clr! a;
#     IO a; write_deref! a stack_ptr; inc! stack_ptr; clr! a;
#     dec! stack_ptr; read_deref! stack_ptr a; a IO;
#     dec! stack_ptr; read_deref! stack_ptr a; a IO;
#     dec! stack_ptr; read_deref! stack_ptr a; a IO;
# 
#     z z HALT; 

func_add:
    dec! stack_ptr; read_deref! stack_ptr func_add_return_addr;

    dec! stack_ptr; read_deref! stack_ptr func_add_a;
    dec! stack_ptr; read_deref! stack_ptr func_add_b;

    add! func_add_a func_add_b;
    write_deref! func_add_b stack_ptr; inc! stack_ptr; jmp! func_add_jump_to_return;
    # drop through to jump_to_return
    
    .data
        func_add_jump_to_return: 0
        0
        func_add_return_addr: 0

        func_add_a: 0
        func_add_b: 0

        func_add_tmp: 0
    .endd



test:
    IO a; write_deref! a stack_ptr; inc! stack_ptr; clr! a;
    IO a; write_deref! a stack_ptr; inc! stack_ptr; clr! a;
    write_deref! return_addr stack_ptr; inc! stack_ptr;
    jmp! func_add;

.data return_addr: ? .endd
return: 
    dec! stack_ptr; read_deref! stack_ptr a; a IO; clr! a;

    z z HALT; 


.data

    a: 0
    stack: 0 0 0 0 0
    stack_ptr: stack
    dest: 0

    z: 0
    p1: 1
    m1: -1

    tmp: 0

    literal_16: 16
    literal_15: 15
.endd

